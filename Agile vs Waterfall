Assignment HW Agile vs Waterfall
 

Assignment HW 6/6/2019 Mr. Aikeem Johnson

 

The SDLC (Software Development Life Cycle) is process software industry uses to design, develop and test software for the needs of the customer. Their job makes sure that they follow the process, that software is made exactly and beyond needs customer so that they continue doing great work they do, as also be paid well work done and on time.  

There are many cycles SDLC go through developing good soft, known cycles Waterfall Model, Iterative Model, Spiral Model, V-Model, Big Bang Model, agile model and more. The two models I will be comparing are Waterfall and Agile Models below. 

 

Agile The agile model point that it is a model that can be run very fast of its software, what helps it be done faster by breaking each process where it can be individually worked one to three weeks, making it faster process all it gets done, without like waterfall, where one must finish the first step then continue with the next, as agile allows all its processes go through once, then gathering all together complete software. Once all put together, customer and stalk holder able get to look through software, its success can their purpose use. Another difference between agile and waterfall models , that agile model runs like an adaptive process as adapts what are concerns software needs, making it as adaptive, change of software needs when called do so, for as waterfall works as predictive because it is exactly known what each step will go through, as continues same beginning to end process. Both agile and waterfall have advantages and disadvantages that help make it ease or issue getting the software needed to be done time. 

 

 

 

Waterfall The waterfall model was first to be introduced to the model processing, it was a simple step, that when started one had to be done completely first assignment, then next would follow only if first was completely done, if the second one needed to go back to first, wasn’t never possible as it would have followed through to next as is the process this model. The waterfall model went through few situations starting with Requirement gathering and analysis, this was the first phase where all its requirements gathered start, as where process then next go through, would continue until done never going through another, but one and only after other. A similarity between agile and waterfall is both works on the time frame, though agile works on a small box time frame, both work at such time so that work is done at the time needed process to be done. Below are few of advantages and simulates id the models agile and waterfall, their process must follow through, that software done time consumer as planned. 

 

Advantages and Disadvantages

 

Waterfall                                                                                                  Agile 

 

Simple easy task                                                                       Task stays the same or can change adapt consumer demands 

 

 

Process predictive that goes one                                            Change good for new softer demands, it's a very realistic approach software developers needs for consumer.

The process to another. 

 

Done according to exactly consumer needs it's model               Little or no talk needed to go through, as process follows through what set needed, as go with flow process.

With no change, but as a planned start to finish.                              

                                                                                                    Agile works only if the customer knows and works get software done, without the customer, know where telling exactly— 

Waterfall model doesn’t exactly change, poising uncertainty

Of the processing model.                                                            Developer start and end every area process making software consumer. 

                                                                                                    

        Waterfall model project end anytime due to adjusting the scope 

model phase.                                                                                Without talk or little talk, makes hard bring software development to the next developers because know                                                                                                                    T                                                                                                     talks or so is available for new developers follow. 

 

Both Agile and waterfall are models that have easy and difficult task software developers follow through, a project takes course from beginning to end, its for the developer change of course or continues knowledge getting job done, fits the demands consumer, who hopefully accepts the needs of ether work be done, making it task well-done software developer. 

 


hw1
edit·good question0Updated 23 days ago by Aikeem
the students' answer,where students collectively construct a single answerActions 
Found this example by Mary Lotz for Segue Technologies.

 

One of the first decisions we face for each of our project implementations at Segue is “Which development methodology should we use?” This is a topic that gets a lot of discussion (and often heated debate). If this is not something you’ve worked with before, a definition of development methodology is in order; put very simply, it’s a way of organizing the work of software development. This is NOT about a style of project management or a specific technical approach, although you will often hear these terms all thrown together or used interchangeably.

The two basic, most popular methodologies are:

Waterfall: (ugh, terrible name!), which might be more properly called the “traditional” approach, and
Agile: a specific type of Rapid Application Development and newer than Waterfall, but not that new, which is often implemented using Scrum.
Both of these are usable, mature methodologies. Having been involved in software development projects for a long time, here are my thoughts on the strengths and weaknesses of each.

The Waterfall Methodology
Waterfall is a linear approach to software development. In this methodology, the sequence of events is something like:

Gather and document requirements
Design
Code and unit test
Perform system testing
Perform user acceptance testing (UAT)
Fix any issues
Deliver the finished product
In a true Waterfall development project, each of these represents a distinct stage of software development, and each stage generally finishes before the next one can begin. There is also typically a stage gate between each; for example, requirements must be reviewed and approved by the customer before design can begin.

There are good things and bad about the Waterfall approach. On the positive side:

Developers and customers agree on what will be delivered early in the development lifecycle. This makes planning and designing more straightforward.
Progress is more easily measured, as the full scope of the work is known in advance.
Throughout the development effort, it’s possible for various members of the team to be involved or to continue with other work, depending on the active phase of the project. For example, business analysts can learn about and document what needs to be done, while the developers are working on other projects. Testers can prepare test scripts from requirements documentation while coding is underway.
Except for reviews, approvals, status meetings, etc., a customer presence is not strictly required after the requirements phase.
Because design is completed early in the development lifecycle, this approach lends itself to projects where multiple software components must be designed (sometimes in parallel) for integration with external systems.
Finally, the software can be designed completely and more carefully, based upon a more complete understanding of all software deliverables. This provides a better software design with less likelihood of the “piecemeal effect,” a development phenomenon that can occur as pieces of code are defined and subsequently added to an application where they may or may not fit well.
Here are some issues we have encountered using a pure Waterfall approach:

One area which almost always falls short is the effectiveness of requirements. Gathering and documenting requirements in a way that is meaningful to a customer is often the most difficult part of software development, in my opinion. Customers are sometimes intimidated by details, and specific details, provided early in the project, are required with this approach. In addition, customers are not always able to visualize an application from a requirements document. Wireframes and mockups can help, but there’s no question that most end users have some difficulty putting these elements together with written requirements to arrive at a good picture of what they will be getting.
Another potential drawback of pure Waterfall development is the possibility that the customer will be dissatisfied with their delivered software product. As all deliverables are based upon documented requirements, a customer may not see what will be delivered until it’s almost finished. By that time, changes can be difficult (and costly) to implement.
The Agile Methodology
Agile is an iterative, team-based approach to development. This approach emphasizes the rapid delivery of an application in complete functional components. Rather than creating tasks and schedules, all time is “time-boxed” into phases called “sprints.” Each sprint has a defined duration (usually in weeks) with a running list of deliverables, planned at the start of the sprint. Deliverables are prioritized by business value as determined by the customer. If all planned work for the sprint cannot be completed, work is reprioritized and the information is used for future sprint planning.

As work is completed, it can be reviewed and evaluated by the project team and customer, through daily builds and end-of-sprint demos. Agile relies on a very high level of customer involvement throughout the project, but especially during these reviews.

Some advantages of the Agile approach are easy to see:

The customer has frequent and early opportunities to see the work being delivered, and to make decisions and changes throughout the development project.
The customer gains a strong sense of ownership by working extensively and directly with the project team throughout the project.
If time to market for a specific application is a greater concern than releasing a full feature set at initial launch, Agile can more quickly produce a basic version of working software which can be built upon in successive iterations.
Development is often more user-focused, likely a result of more and frequent direction from the customer.
For more Agile Development benefits, please see 8 Benefits of Agile Software Development
And, of course, there are some disadvantages:

The very high degree of customer involvement, while great for the project, may present problems for some customers who simply may not have the time or interest for this type of participation.
Agile works best when members of the development team are completely dedicated to the project.
Because Agile focuses on time-boxed delivery and frequent reprioritization, it’s possible that some items set for delivery will not be completed within the allotted timeframe. Additional sprints (beyond those initially planned) may be needed, adding to the project cost. In addition, customer involvement often leads to additional features requested throughout the project. Again, this can add to the overall time and cost of the implementation.
The close working relationships in an Agile project are easiest to manage when the team members are located in the same physical space, which is not always possible. However, there are a variety of ways to handle this issue, such as webcams, collaboration tools, etc.
The iterative nature of Agile development may lead to a frequent refactoring if the full scope of the system is not considered in the intial architecture and design. Without this refactoring, the system can suffer from a reduction in overall quality. This becomes more pronounced in larger-scale implementations, or with systems that include a high level of integration.
Making the Choice Between Agile and Waterfall
So, how do we choose? First, we change the game a little (which is what most software development organizations do) by defining our own process. At Segue, it’s called our Process Framework, and it’s a variation on the traditional Waterfall methodology. Our modifications include use of prototyping where possible to provide the customer a better view of their finished product early in the design/development cycle. This helps to improve the team’s understanding of requirements and communication with the customer. After the primary framework of the application is completed per high level requirements, we continue to develop and also to reach out to the customer for refinement of requirements. In this way, we strive to be as iterative as possible without compromising our overall system architecture.
